#    generate_pos: Tells whether to generate an object storing the
#        positions of the nonzeros in the matrix
#    basic: Tells whether to use basic RAPPOR (only works if h=1).
M <- length(strs)
map_by_cohort <- list()
k <- params$k
h <- params$h
m <- params$m
for (i in 1:m) {
if (basic && (h == 1) && (k == M)) {
ones <- 1:M
} else {
ones <- sample(1:k, M * h, replace = TRUE)
}
cols <- rep(1:M, each = h)
map_by_cohort[[i]] <- sparseMatrix(ones, cols, dims = c(k, M))
colnames(map_by_cohort[[i]]) <- strs
}
all_cohorts_map <- do.call("rBind", map_by_cohort)
if (generate_pos) {
map_pos <- t(apply(all_cohorts_map, 2, function(x) {
ind <- which(x == 1)
n <- length(ind)
if (n < h * m) {
ind <- c(ind, rep(NA, h * m - n))
}
ind
}))
} else {
map_pos <- NULL
}
list(map_by_cohort = map_by_cohort, all_cohorts_map = all_cohorts_map,
map_pos = map_pos)
}
CreateMap(strs, params)
library(glmnet)
CreateMap <- function(strs, params, generate_pos = TRUE, basic = FALSE) {
# Creates a list of 0/1 matrices corresponding to mapping between the strs and
# Bloom filters for each instance of the RAPPOR.
# Ex. for 3 strings, 2 instances, 1 hash function and Bloom filter of size 4,
# the result could look this:
# [[1]]
#   1 0 0 0
#   0 1 0 0
#   0 0 0 1
# [[2]]
#   0 1 0 0
#   0 0 0 1
#   0 0 1 0
#
# Args:
#    strs: a vector of strings
#    params: a list of parameters in the following format:
#         (k, h, m, p, q, f).
#    generate_pos: Tells whether to generate an object storing the
#        positions of the nonzeros in the matrix
#    basic: Tells whether to use basic RAPPOR (only works if h=1).
M <- length(strs)
map_by_cohort <- list()
k <- params$k
h <- params$h
m <- params$m
for (i in 1:m) {
if (basic && (h == 1) && (k == M)) {
ones <- 1:M
} else {
ones <- sample(1:k, M * h, replace = TRUE)
}
cols <- rep(1:M, each = h)
map_by_cohort[[i]] <- sparseMatrix(ones, cols, dims = c(k, M))
colnames(map_by_cohort[[i]]) <- strs
}
all_cohorts_map <- do.call("rBind", map_by_cohort)
if (generate_pos) {
map_pos <- t(apply(all_cohorts_map, 2, function(x) {
ind <- which(x == 1)
n <- length(ind)
if (n < h * m) {
ind <- c(ind, rep(NA, h * m - n))
}
ind
}))
} else {
map_pos <- NULL
}
list(map_by_cohort = map_by_cohort, all_cohorts_map = all_cohorts_map,
map_pos = map_pos)
}
CreateMap(strs, params)
params
??sample
1:k
1:params$k
??rep
CreateMap(strs, params)
CreateMap(strs, params)
strs
strs = list("x", "y")
CreateMap(strs, params)
??read.from.csv
??read.from.csv
?read.from.csv
??read.csv
?read.csv
#!/usr/bin/env Rscript
args = ["./outputs/cohorts.csv", "./outputs/counts.csv", "./outputs/params.csv"]
args = c("./outputs/cohorts.csv", "./outputs/counts.csv", "./outputs/params.csv")
params = as.data.frame(read.csv(args[3]))
args = c("outputs/cohorts.csv", "outputs/counts.csv", "outputs/params.csv")
params = as.data.frame(read.csv(args[3]))
pwd()
pwd
getwd()
Rscript --hel
Rscript --help
version
args = c("outputs/cohorts.csv", "outputs/counts.csv", "outputs/params.csv")
params = as.data.frame(read.csv(args[3]))
setwd("~/Dropbox/rappor-js/server")
params = as.data.frame(read.csv(args[3]))
counts = read.csv(args[2], header=FALSE)
totalCounts = counts["V1"]
bitCounts   = counts[-1]
totalCounts
bitCounts
sum(bitCounts)
64*12
64*15
matrix(rep(seq(5), 4), ncol = 5)
counts = as.matrix(read.csv(args[2], header=FALSE))
counts
totalCounts = counts["V1"]
bitCounts   = counts[-1]
bitCounts   = counts[-1]
bitCounts
bitCounts   = counts[,-1]
bitCounts
apply(counts, 2, function(x) (x - numeratorCoeff*x[0])/denominatorCoeff)
numeratorCoeff   = (params["p"] + 0.5*params["f"]*params["q"] - 0.5*params["f"]*params["p"])
denominatorCoeff = (1-params["f"])*(1-params["q"])
apply(counts, 2, function(x) (x - numeratorCoeff*x[0])/denominatorCoeff)
apply(counts, 2, function(x) (x - numeratorCoeff*x[0])/denominatorCoeff)
bitCounts
bitCounts[1, 2]
for (i in 1:params["m"]) {
for (j in 1:params["k"]) {
bitCounts[i, j] = (bitCounts[i, j] - numeratorCoeff*totalCounts[i]) / denominatorCoeff
}
}
params["m"]
as.integer(params["m"])
for (i in 1:as.integer(params["m"])) {
for (j in 1:as.integer(params["k"])) {
bitCounts[i, j] = (bitCounts[i, j] - numeratorCoeff*totalCounts[i]) / denominatorCoeff
}
}
dim(bitCounts)
bitCounts
bitCounts
bitCounts   = counts[,-1]
bitCounts
dim(bitCounts)
for (i in 1:as.integer(params["m"])) {
for (j in 1:as.integer(params["k"])) {
bitCounts[i, j] = (bitCounts[i, j] - numeratorCoeff*totalCounts[i]) / denominatorCoeff
}
}
bitCounts
numeratorCoeff
params
params = as.matrix(read.csv(args[3]))
params
numeratorCoeff   = (params["p"] + 0.5*params["f"]*params["q"] - 0.5*params["f"]*params["p"])
data.frame
numeratorCoeff   = (params["p"] + 0.5*params["f"]*params["q"] - 0.5*params["f"]*params["p"])
params = as.data.frame(read.csv(args[3]))
numeratorCoeff   = (params["p"] + 0.5*params["f"]*params["q"] - 0.5*params["f"]*params["p"])
denominatorCoeff = (1-params["f"])*(1-params["q"])
numeratorCoeff
as.matrix(numeratorCoeff)
as.matrix(numeratorCoeff)[0]
as.matrix(numeratorCoeff)[1]
numeratorCoeff   = as.matrix((params["p"] + 0.5*params["f"]*params["q"] - 0.5*params["f"]*params["p"]))[1]
denominatorCoeff = as.matrix((1-params["f"])*(1-params["q"]))[1]
for (i in 1:as.integer(params["m"])) {
for (j in 1:as.integer(params["k"])) {
bitCounts[i, j] = (bitCounts[i, j] - numeratorCoeff*totalCounts[i]) / denominatorCoeff
}
}
bitCounts   = counts[,-1]
for (i in 1:as.integer(params["m"])) {
for (j in 1:as.integer(params["k"])) {
bitCounts[i, j] = (bitCounts[i, j] - numeratorCoeff*totalCounts[i]) / denominatorCoeff
}
}
bitCounts
bitCounts   = counts[,-1]
bitCounts
numeratorCoeff   = as.matrix((params["p"] + 0.5*params["f"]*params["q"] - 0.5*params["f"]*params["p"]))[1]
denominatorCoeff = as.matrix((1-params["f"])*(1-params["q"]))[1]
numeratorCoeff
totalCOunts[2]
totalCounts[2]
totalCounts = counts["V1"]
totalCounts[2]
totalCounts
counts
totalCounts = counts[1]
totalCounts[2]
totalCounts = counts[1,]
totalCounts[2]
totalCounts
counts
totalCounts = counts[,1]
totalCounts
for (i in 1:as.integer(params["m"])) {
for (j in 1:as.integer(params["k"])) {
bitCounts[i, j] = (bitCounts[i, j] - numeratorCoeff*totalCounts[i]) / denominatorCoeff
}
}
bitCounts
numeratorCoeff   = as.matrix((params["p"] + 0.5*params["f"]*params["q"] - 0.5*params["f"]*params["p"]))[1]
denominatorCoeff = as.matrix((1-params["f"])*(1-params["q"]))[1]
numeratorCoeff
denominatorCoeff = as.matrix((1-params["f"])*(params["q"]-params["p"]))[1]
bitCounts   = counts[,-1]
for (i in 1:as.integer(params["m"])) {
for (j in 1:as.integer(params["k"])) {
bitCounts[i, j] = (bitCounts[i, j] - numeratorCoeff*totalCounts[i]) / denominatorCoeff
}
}
bitCounts
numeratorCoeff
denominatorCoeff
params
install.packages('shiny')
install.packages('shiny')
CreateMap <- function(strs, params, generate_pos = TRUE, basic = FALSE) {
# Creates a list of 0/1 matrices corresponding to mapping between the strs and
# Bloom filters for each instance of the RAPPOR.
# Ex. for 3 strings, 2 instances, 1 hash function and Bloom filter of size 4,
# the result could look this:
# [[1]]
#   1 0 0 0
#   0 1 0 0
#   0 0 0 1
# [[2]]
#   0 1 0 0
#   0 0 0 1
#   0 0 1 0
#
# Args:
#    strs: a vector of strings
#    params: a list of parameters in the following format:
#         (k, h, m, p, q, f).
#    generate_pos: Tells whether to generate an object storing the
#        positions of the nonzeros in the matrix
#    basic: Tells whether to use basic RAPPOR (only works if h=1).
M <- length(strs)
map_by_cohort <- list()
k <- params$k
h <- params$h
m <- params$m
for (i in 1:m) {
if (basic && (h == 1) && (k == M)) {
ones <- 1:M
} else {
ones <- sample(1:k, M * h, replace = TRUE)
}
cols <- rep(1:M, each = h)
map_by_cohort[[i]] <- sparseMatrix(ones, cols, dims = c(k, M))
colnames(map_by_cohort[[i]]) <- strs
}
all_cohorts_map <- do.call("rBind", map_by_cohort)
if (generate_pos) {
map_pos <- t(apply(all_cohorts_map, 2, function(x) {
ind <- which(x == 1)
n <- length(ind)
if (n < h * m) {
ind <- c(ind, rep(NA, h * m - n))
}
ind
}))
} else {
map_pos <- NULL
}
list(map_by_cohort = map_by_cohort, all_cohorts_map = all_cohorts_map,
map_pos = map_pos)
}
CreateMap <- function(strs, params, generate_pos = TRUE, basic = FALSE) {
# Creates a list of 0/1 matrices corresponding to mapping between the strs and
# Bloom filters for each instance of the RAPPOR.
# Ex. for 3 strings, 2 instances, 1 hash function and Bloom filter of size 4,
# the result could look this:
# [[1]]
#   1 0 0 0
#   0 1 0 0
#   0 0 0 1
# [[2]]
#   0 1 0 0
#   0 0 0 1
#   0 0 1 0
#
# Args:
#    strs: a vector of strings
#    params: a list of parameters in the following format:
#         (k, h, m, p, q, f).
#    generate_pos: Tells whether to generate an object storing the
#        positions of the nonzeros in the matrix
#    basic: Tells whether to use basic RAPPOR (only works if h=1).
M <- length(strs)
map_by_cohort <- list()
k <- 16
h <- 3
m <- 64
for (i in 1:m) {
if (basic && (h == 1) && (k == M)) {
ones <- 1:M
} else {
ones <- sample(1:k, M * h, replace = TRUE)
}
cols <- rep(1:M, each = h)
map_by_cohort[[i]] <- sparseMatrix(ones, cols, dims = c(k, M))
colnames(map_by_cohort[[i]]) <- strs
}
all_cohorts_map <- do.call("rBind", map_by_cohort)
if (generate_pos) {
map_pos <- t(apply(all_cohorts_map, 2, function(x) {
ind <- which(x == 1)
n <- length(ind)
if (n < h * m) {
ind <- c(ind, rep(NA, h * m - n))
}
ind
}))
} else {
map_pos <- NULL
}
list(map_by_cohort = map_by_cohort, all_cohorts_map = all_cohorts_map,
map_pos = map_pos)
}
CreateMap(c("hi", "bye"))
CreateMap <- function(strs, generate_pos = TRUE, basic = FALSE) {
# Creates a list of 0/1 matrices corresponding to mapping between the strs and
# Bloom filters for each instance of the RAPPOR.
# Ex. for 3 strings, 2 instances, 1 hash function and Bloom filter of size 4,
# the result could look this:
# [[1]]
#   1 0 0 0
#   0 1 0 0
#   0 0 0 1
# [[2]]
#   0 1 0 0
#   0 0 0 1
#   0 0 1 0
#
# Args:
#    strs: a vector of strings
#    params: a list of parameters in the following format:
#         (k, h, m, p, q, f).
#    generate_pos: Tells whether to generate an object storing the
#        positions of the nonzeros in the matrix
#    basic: Tells whether to use basic RAPPOR (only works if h=1).
M <- length(strs)
map_by_cohort <- list()
k <- 16
h <- 3
m <- 64
for (i in 1:m) {
if (basic && (h == 1) && (k == M)) {
ones <- 1:M
} else {
ones <- sample(1:k, M * h, replace = TRUE)
}
cols <- rep(1:M, each = h)
map_by_cohort[[i]] <- sparseMatrix(ones, cols, dims = c(k, M))
colnames(map_by_cohort[[i]]) <- strs
}
all_cohorts_map <- do.call("rBind", map_by_cohort)
if (generate_pos) {
map_pos <- t(apply(all_cohorts_map, 2, function(x) {
ind <- which(x == 1)
n <- length(ind)
if (n < h * m) {
ind <- c(ind, rep(NA, h * m - n))
}
ind
}))
} else {
map_pos <- NULL
}
list(map_by_cohort = map_by_cohort, all_cohorts_map = all_cohorts_map,
map_pos = map_pos)
}
CreateMap(c("hi", "bye"))
library(glmnet)
CreateMap <- function(strs, generate_pos = TRUE, basic = FALSE) {
# Creates a list of 0/1 matrices corresponding to mapping between the strs and
# Bloom filters for each instance of the RAPPOR.
# Ex. for 3 strings, 2 instances, 1 hash function and Bloom filter of size 4,
# the result could look this:
# [[1]]
#   1 0 0 0
#   0 1 0 0
#   0 0 0 1
# [[2]]
#   0 1 0 0
#   0 0 0 1
#   0 0 1 0
#
# Args:
#    strs: a vector of strings
#    params: a list of parameters in the following format:
#         (k, h, m, p, q, f).
#    generate_pos: Tells whether to generate an object storing the
#        positions of the nonzeros in the matrix
#    basic: Tells whether to use basic RAPPOR (only works if h=1).
M <- length(strs)
map_by_cohort <- list()
k <- 16
h <- 3
m <- 64
for (i in 1:m) {
if (basic && (h == 1) && (k == M)) {
ones <- 1:M
} else {
ones <- sample(1:k, M * h, replace = TRUE)
}
cols <- rep(1:M, each = h)
map_by_cohort[[i]] <- sparseMatrix(ones, cols, dims = c(k, M))
colnames(map_by_cohort[[i]]) <- strs
}
all_cohorts_map <- do.call("rBind", map_by_cohort)
if (generate_pos) {
map_pos <- t(apply(all_cohorts_map, 2, function(x) {
ind <- which(x == 1)
n <- length(ind)
if (n < h * m) {
ind <- c(ind, rep(NA, h * m - n))
}
ind
}))
} else {
map_pos <- NULL
}
list(map_by_cohort = map_by_cohort, all_cohorts_map = all_cohorts_map,
map_pos = map_pos)
}
CreateMap(c("hi", "bye"))
library(glmnet)
CreateMap <- function(strs, generate_pos = TRUE, basic = FALSE) {
# Creates a list of 0/1 matrices corresponding to mapping between the strs and
# Bloom filters for each instance of the RAPPOR.
# Ex. for 3 strings, 2 instances, 1 hash function and Bloom filter of size 4,
# the result could look this:
# [[1]]
#   1 0 0 0
#   0 1 0 0
#   0 0 0 1
# [[2]]
#   0 1 0 0
#   0 0 0 1
#   0 0 1 0
#
# Args:
#    strs: a vector of strings
#    params: a list of parameters in the following format:
#         (k, h, m, p, q, f).
#    generate_pos: Tells whether to generate an object storing the
#        positions of the nonzeros in the matrix
#    basic: Tells whether to use basic RAPPOR (only works if h=1).
M <- length(strs)
map_by_cohort <- list()
k <- 16
h <- 3
m <- 8
for (i in 1:m) {
if (basic && (h == 1) && (k == M)) {
ones <- 1:M
} else {
ones <- sample(1:k, M * h, replace = TRUE)
}
cols <- rep(1:M, each = h)
map_by_cohort[[i]] <- sparseMatrix(ones, cols, dims = c(k, M))
colnames(map_by_cohort[[i]]) <- strs
}
all_cohorts_map <- do.call("rBind", map_by_cohort)
if (generate_pos) {
map_pos <- t(apply(all_cohorts_map, 2, function(x) {
ind <- which(x == 1)
n <- length(ind)
if (n < h * m) {
ind <- c(ind, rep(NA, h * m - n))
}
ind
}))
} else {
map_pos <- NULL
}
list(map_by_cohort = map_by_cohort, all_cohorts_map = all_cohorts_map,
map_pos = map_pos)
}
CreateMap(c("hi", "bye"))
CreateMap(c("hi", "bye"))
CreateMap(c("hi", "bye"))
CreateMap(c("hi", "bye"))
params
params$f
params$h
source("decode.R")
setwd("~/Dropbox/rappor-js/server")
source("decode.R")
